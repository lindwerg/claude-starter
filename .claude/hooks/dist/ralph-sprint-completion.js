// src/ralph-sprint-completion.ts
import * as fs3 from "fs/promises";
import * as path from "path";
import { exec as exec3 } from "child_process";
import { promisify as promisify3 } from "util";
import YAML from "yaml";

// src/types.ts
async function readStdin() {
  return new Promise((resolve) => {
    let data = "";
    process.stdin.setEncoding("utf8");
    process.stdin.on("data", (chunk) => data += chunk);
    process.stdin.on("end", () => resolve(data));
  });
}
function output(result) {
  console.log(JSON.stringify(result));
}

// src/lib/sprint-review-generator.ts
import * as fs from "fs/promises";
import { exec } from "child_process";
import { promisify } from "util";

// src/lib/task-queue-types.ts
function groupTasksByStory(tasks) {
  const storiesMap = /* @__PURE__ */ new Map();
  for (const task of tasks) {
    if (!storiesMap.has(task.story_id)) {
      storiesMap.set(task.story_id, []);
    }
    storiesMap.get(task.story_id).push(task);
  }
  return Array.from(storiesMap.entries()).map(([story_id, tasks2]) => ({
    story_id,
    tasks: tasks2,
    total_tasks: tasks2.length,
    completed_tasks: tasks2.filter((t) => t.status === "done").length
  }));
}
function calculateTotalDuration(tasks) {
  return tasks.filter((t) => t.receipt?.duration_minutes).reduce((sum, t) => sum + t.receipt.duration_minutes, 0);
}
function getCommitsFromTasks(tasks) {
  return tasks.filter((t) => t.receipt?.commit_hash).map((t) => t.receipt.commit_hash);
}

// src/lib/sprint-review-generator.ts
var execAsync = promisify(exec);
async function generateSprintReview(queue) {
  console.log("\n\u{1F4DD} Generating Sprint Review...\n");
  const stories = groupTasksByStory(queue.tasks);
  const completedStories = stories.filter((s) => s.completed_tasks === s.total_tasks);
  const commits = getCommitsFromTasks(queue.tasks);
  const totalDuration = calculateTotalDuration(queue.tasks);
  const learnings = await readLearningsFromScratchpad();
  const review = `# Sprint ${queue.sprint} Review

**Completed:** ${(/* @__PURE__ */ new Date()).toISOString()}

## Summary

- **Sprint:** ${queue.sprint}
- **Stories:** ${completedStories.length}/${stories.length} completed
- **Tasks:** ${queue.summary.completed_tasks}/${queue.summary.total_tasks} done
- **Commits:** ${commits.length}
- **Duration:** ${Math.round(totalDuration / 60)} hours

## Stories Delivered

${renderStories(stories)}

## Git Commits

${commits.length > 0 ? renderCommits(commits) : "_No commits recorded_"}

## Blockers & Learnings

${learnings.length > 0 ? learnings.join("\n") : "_No learnings recorded_"}

---

_Generated by Ralph Loop Sprint Automation_
`;
  return review;
}
function renderStories(stories) {
  return stories.map((story) => {
    const status = story.completed_tasks === story.total_tasks ? "\u2705" : "\u23F3";
    const tasks = story.tasks.map((task) => {
      const taskStatus = task.status === "done" ? "\u2705" : "\u23F3";
      return `  - ${taskStatus} ${task.id}: ${task.title}`;
    }).join("\n");
    return `### ${status} ${story.story_id} (${story.completed_tasks}/${story.total_tasks} tasks)

${tasks}
`;
  }).join("\n");
}
function renderCommits(commits) {
  return commits.map((hash) => `- \`${hash}\``).join("\n");
}
async function readLearningsFromScratchpad() {
  try {
    const content = await fs.readFile(".bmad/scratchpad.md", "utf-8");
    const learningsMatch = content.match(/learnings:\s*\n((?:  - .+\n?)+)/);
    if (learningsMatch) {
      const learningsText = learningsMatch[1];
      return learningsText.split("\n").filter((line) => line.trim().startsWith("- ")).map((line) => line.trim());
    }
    return [];
  } catch (error) {
    return [];
  }
}

// src/lib/quality-checker.ts
import { exec as exec2 } from "child_process";
import { promisify as promisify2 } from "util";
import * as fs2 from "fs/promises";
var execAsync2 = promisify2(exec2);
async function runQualityCheck() {
  console.log("\n\u{1F50D} Running quality gates...\n");
  const errors = [];
  console.log("\u{1F4DD} Running typecheck...");
  const typecheck = await runTypecheck();
  if (!typecheck.passed) {
    errors.push(...typecheck.errors);
    console.error(`  \u274C Typecheck failed: ${typecheck.errors.length} error(s)`);
  } else {
    console.log(`  \u2705 Typecheck passed`);
  }
  console.log("\n\u{1F527} Running lint...");
  const lint = await runLint();
  if (!lint.passed) {
    errors.push(`Lint: ${lint.errors} error(s), ${lint.warnings} warning(s)`);
    console.error(`  \u274C Lint failed: ${lint.errors} error(s)`);
  } else {
    console.log(`  \u2705 Lint passed (${lint.warnings} warnings)`);
  }
  console.log("\n\u{1F9EA} Running tests...");
  const tests = await runTests();
  if (!tests.passed) {
    errors.push(`Tests: ${tests.failed}/${tests.total} failed`);
    console.error(`  \u274C Tests failed: ${tests.failed}/${tests.total}`);
  } else {
    console.log(`  \u2705 Tests passed: ${tests.passed_count}/${tests.total}`);
  }
  console.log("\n\u{1F4CA} Reading coverage...");
  const coverage = await readCoverage();
  console.log(`  \u{1F4C8} Coverage: ${coverage.lines}% lines`);
  const allPassed = typecheck.passed && lint.passed && tests.passed;
  return {
    allPassed,
    typecheck,
    lint,
    tests,
    coverage,
    errors
  };
}
async function runTypecheck() {
  try {
    await execAsync2("pnpm typecheck", { timeout: 6e4 });
    return { passed: true, errors: [] };
  } catch (error) {
    const stderr = error.stderr || "";
    const errors = parseTypescriptErrors(stderr);
    return { passed: false, errors };
  }
}
async function runLint() {
  try {
    const { stdout } = await execAsync2("pnpm lint", { timeout: 6e4 });
    return { passed: true, warnings: 0, errors: 0 };
  } catch (error) {
    const stdout = error.stdout || "";
    const parsed = parseEslintOutput(stdout);
    return {
      passed: parsed.errors === 0,
      warnings: parsed.warnings,
      errors: parsed.errors
    };
  }
}
async function runTests() {
  try {
    const { stdout } = await execAsync2("pnpm test -- --reporter=json", {
      timeout: 3e5
      // 5 min
    });
    const report = JSON.parse(stdout);
    return {
      passed: report.numFailedTests === 0,
      total: report.numTotalTests || 0,
      passed_count: report.numPassedTests || 0,
      failed: report.numFailedTests || 0
    };
  } catch (error) {
    try {
      await execAsync2("pnpm test", { timeout: 3e5 });
      return { passed: true, total: 0, passed_count: 0, failed: 0 };
    } catch (fallbackError) {
      return { passed: false, total: 0, passed_count: 0, failed: 1 };
    }
  }
}
async function readCoverage() {
  try {
    const content = await fs2.readFile("coverage/coverage-summary.json", "utf-8");
    const summary = JSON.parse(content);
    const total = summary.total || {};
    return {
      lines: total.lines?.pct || 0,
      statements: total.statements?.pct || 0,
      functions: total.functions?.pct || 0,
      branches: total.branches?.pct || 0
    };
  } catch (error) {
    return { lines: 0, statements: 0, functions: 0, branches: 0 };
  }
}
function parseTypescriptErrors(stderr) {
  const lines = stderr.split("\n").filter((line) => line.includes("error TS"));
  return lines.slice(0, 10);
}
function parseEslintOutput(stdout) {
  const warningsMatch = stdout.match(/(\d+) warnings?/);
  const errorsMatch = stdout.match(/(\d+) errors?/);
  return {
    warnings: warningsMatch ? parseInt(warningsMatch[1], 10) : 0,
    errors: errorsMatch ? parseInt(errorsMatch[1], 10) : 0
  };
}

// src/ralph-sprint-completion.ts
var execAsync3 = promisify3(exec3);
async function main() {
  const input = JSON.parse(await readStdin());
  try {
    const taskQueuePath = ".bmad/task-queue.yaml";
    const exists = await fileExists(taskQueuePath);
    if (!exists) {
      return output({ result: "continue" });
    }
    const content = await fs3.readFile(taskQueuePath, "utf-8");
    const queue = YAML.parse(content);
    const allDone = queue.tasks.every((task) => task.status === "done");
    if (!allDone) {
      return output({ result: "continue" });
    }
    console.error("\n\u{1F389} Sprint completed! Processing...\n");
    const sprintReview = await generateSprintReview(queue);
    const qualityReport = await runQualityCheck();
    await archiveSprint(queue, sprintReview, qualityReport);
    await fs3.writeFile(".bmad/sprint-validation-pending", (/* @__PURE__ */ new Date()).toISOString(), "utf-8");
    await openBrowser();
    return output({
      result: "block",
      message: `
\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501
\u{1F3C1} SPRINT ${queue.sprint} COMPLETED
\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501

\u2705 All tasks completed
\u{1F4E6} Archived to: .bmad/history/sprint-${queue.sprint}/
\u{1F50D} Quality gates: ${qualityReport.allPassed ? "PASSED" : "FAILED"}
\u{1F310} Browser opened for manual validation

\u{1F4CB} NEXT STEP: Run /validate-sprint to:
   1. Test the application manually
   2. Generate task-queue.yaml for Sprint ${queue.sprint + 1}
   3. Continue Ralph Loop automatically

\u26A0\uFE0F  Ralph Loop is BLOCKED until validation completes
\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501
`
    });
  } catch (error) {
    console.error("\u274C Sprint completion error:", error);
    return output({ result: "continue" });
  }
}
async function archiveSprint(queue, sprintReview, qualityReport) {
  const sprintDir = `.bmad/history/sprint-${queue.sprint}`;
  await fs3.mkdir(sprintDir, { recursive: true });
  await fs3.copyFile(".bmad/task-queue.yaml", path.join(sprintDir, "task-queue.yaml"));
  await fs3.writeFile(path.join(sprintDir, "sprint-review.md"), sprintReview, "utf-8");
  await fs3.writeFile(
    path.join(sprintDir, "quality-report.json"),
    JSON.stringify(qualityReport, null, 2),
    "utf-8"
  );
  const commits = getCommitsFromTasks(queue.tasks);
  await fs3.writeFile(path.join(sprintDir, "commits.log"), commits.join("\n"), "utf-8");
  console.error(`\u2705 Sprint archived to: ${sprintDir}`);
}
async function openBrowser() {
  const url = "http://localhost:3000";
  try {
    let command;
    switch (process.platform) {
      case "darwin":
        command = `open ${url}`;
        break;
      case "linux":
        command = `xdg-open ${url}`;
        break;
      case "win32":
        command = `start ${url}`;
        break;
      default:
        console.error(`\u26A0\uFE0F  Platform not supported for browser opening: ${process.platform}`);
        console.error(`   Please open manually: ${url}`);
        return;
    }
    await execAsync3(command);
    console.error(`\u2705 Browser opened: ${url}`);
  } catch (error) {
    console.error(`\u26A0\uFE0F  Failed to open browser: ${error.message}`);
    console.error(`   Please open manually: ${url}`);
  }
}
async function fileExists(filePath) {
  try {
    await fs3.access(filePath);
    return true;
  } catch {
    return false;
  }
}
main();
